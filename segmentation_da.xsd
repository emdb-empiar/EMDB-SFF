<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
    targetNamespace="http://pdbe.org/empiarSFF" xmlns="http://pdbe.org/empiarSFF">

    <!-- BEGIN MAIN STRUCTURE -->

    <xs:element name="segmentation">
        <xs:annotation>
            <xs:documentation>Link to assembly or component id.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="xs:string"/>
                <xs:element name="software" type="softwareType" minOccurs="0"/>
                <xs:element name="transformList" minOccurs="0">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element ref="transform" minOccurs="0" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="filePath" type="xs:token">
                    <xs:annotation>
                        <xs:documentation>Specifies the location of file containing referenced data.
                            Applies to 'threeDVolume' and 'subtomogramAverage'. If its value is an
                            empty string then the full path is assumed to be contained in the 'file'
                            attribute that refers to the data ('threeDVolume' or
                            'subtomogramAverage'). Otherwise it is assumed to be a full path
                            excluding the filename. This is consistent with concatenating the
                            'filePath' content with the 'file' content.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="primaryDescriptor">
                    <xs:annotation>
                        <xs:documentation>Mandatory field. Designates the element type within
                            'segmentList' that contains the primary description of the segments.
                            Constrained to be either 'threeDVolume', 'shapePrimitiveList',
                            'contourList' or 'meshList'.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:string">
                            <xs:enumeration value="threeDVolume"/>
                            <xs:enumeration value="shapePrimitiveList"/>
                            <xs:enumeration value="contourList"/>
                            <xs:enumeration value="meshList"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="segmentList">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="segment" type="segmentType" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="details" type="xs:string" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="schemaVersion" type="xs:token" fixed="0.5.4">
                <xs:annotation>
                    <xs:documentation>
                        <![CDATA[
                        Version History 
                        0.2, 2015/3/15, Ardan Patwardhan: 
                        1) Added support for color 
                        2) Added support for triangle representation of segment - this is in support of Amira segmentations 
                        
                        0.3, 2015/10/21, Paul Korir: 
                        1) Added voxelTransform 
                        2) Added filePath for segmentLinks to HDF5 (Segger) segmentations 
                        3) Added segmentObjects with contours and meshes for IMOD 
                        
                        0.4, 2015/11/04, Paul Korir: 
                        1) Added alpha for rgb color (transparency) 
                        
                        0.5, 2015/12/14, Paul Korir: 
                        1) Removed 'voxelTransform'
                        2) Moved 'numberOfCopies' as 'numberOfInstances' to  be a sequence element within 'biologicalAnnotation'
                        3) Made 'color' a choice between 'name' (X11/HTML4 sRGB colour space names) and 'rgba'
                        4) Added a 'transform' element, which is a possibly empty list of transformation matrices referenced within the document by a non-negative identifier
                        5) Renamed 'segmentLink' to 'voxelSegmentation' and added a 'transformId' element
                        6) Renamed 'color' element to 'colour' and 'colorType' to 'colourType'
                        7) Structured 'shapePrimitive' to a list of 'shapePrimitive' (substitution group for 'ellipsoid', 'cuboid', 'pyramid', 'cylinder')
                        8) Identified and labeled deprecated data types
                        9) Renamed shapePrimitive 'pyramid' to 'cone' and added tentative definition
                        10) Removed 'origin' and 'viewVectorRotation' elements from shape primitives (cuboid, ellipsoid, cone, cylinder) and replaced with 'transformId' element
                        11) Renamed references to 'triangles' to 'polygons' e.g. 'triangleListType' now 'polygonListType'
                        
                        0.5.1, 2015/12/23, Paul Korir:
                        1) Change colourType to have rgbaType minOccurs=1
                        2) Added 'attribute' element (e.g. for FOM) to shapePrimitive
                        3) Deleted comment: 'Are the CCP4 format masks going to be allowed? If so, we could represent the information of the mask (mapType) here.' from 'voxelSegmentation'.
                        4) Added segment 'format' element to 'voxelSegmentation' restricted to values 'runLengthEncoding', 'MRC', or 'Segger'
                        5) Renamed 'voxelSegmentation' to 'threeDVolume' and deprecated 'subTomogramAverage'.
                        6) Restructured 'transforms' into a list ('transformList') of 'transform', which is a substitutionGroup of 'transformationMatrix', 'canonicalEulerAngles' or 'viewVectorRotation'. 
                        7) Added an 'angleDegreeType' to restrict angle range in degrees [0,360].
                        
                        0.5.2, 2016/01/04, Paul Korir:
                        1) Made 'transformList' optional
                        2) Added 'id' attributes for 'canonicalEulerAngle' and 'viewVectorRotation'
                        3) Annotations for 'filePath'
                        4) Added 'other' to types for 'externalReference' and optional 'otherTypes' attribute
                        5) Changed type of 'name' element in 'colour' from 'xs:string' to 'xs:token'
                        6) Created 'threeDVolumeType' to be used by 'threeDVolume' and 'subtomogramAverage'
                        7) Added 'id' attributes for 'shapePrimitive' and 'threeDVolumeType'
                        8) Renamed 'contours' to 'contourList'
                        9) Created 'meshList' as a sequence of 'mesh'. Each 'mesh' has an 'id'
                        
                        0.5.3, 2016/01/06, Paul Korir:
                        1) Renamed 'transformationMatrixType' attribute from 'transformId' to 'id'
                        2) Created 'dimensionType' for all 'shapePrimitive' dimensions
                        
                        0.5.4, 2016/01/06, Paul Korir:
                        1) Added element 'primaryDescriptor' of type restricted string to 'threeDVolume', 'shapePrimitiveList', 'contourList', 'meshList'
                        
                        0.5.5, 2016/01/22, Paul Korir:
                        1) Changed 'vertices' and 'polygons' to 'vertexList' and 'polygonList', respectively.
                        ]]>
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <!-- END MAIN STRUCTURE -->


    <!-- BEGIN REFERENCED TYPES (in order of reference) -->

    <!-- softwareType -->
    <xs:complexType name="softwareType">
        <xs:sequence>
            <xs:element name="name" type="xs:token"/>
            <xs:element name="version" type="xs:token" minOccurs="0"/>
            <xs:element name="processingDetails" type="xs:string" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <!-- transformationMatrixType -->
    <xs:complexType name="transformationMatrixType">
        <xs:annotation>
            <xs:documentation>data is a space-separated sequence of numbers to be converted to
                floats. The number of items in 'data' is equivalent to the product of 'rows' and
                'cols'.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="rows" type="xs:positiveInteger"/>
            <xs:element name="cols" type="xs:positiveInteger"/>
            <xs:element name="data" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- canonicalEulerAnglesType -->
    <xs:complexType name="canonicalEulerAnglesType">
        <xs:annotation>
            <xs:documentation>Euler angler according to Heymann et al. 2005
                (doi:10.1016/j.jsb.2005.06.001)</xs:documentation>
            <xs:documentation>Angles are specified in degrees together with their
                bounds.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="phi" type="angleDegreeType"/>
            <xs:element name="theta" type="angleDegreeType"/>
            <xs:element name="psi" type="angleDegreeType"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- viewVectorRotationType -->
    <xs:complexType name="viewVectorRotationType">
        <xs:sequence>
            <xs:element name="x" type="xs:float"/>
            <xs:element name="y" type="xs:float"/>
            <xs:element name="z" type="xs:float"/>
            <xs:element name="r" type="angleDegreeType"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- angleDegreeType -->
    <xs:simpleType name="angleDegreeType">
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0"/>
            <xs:maxInclusive value="360"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- segmentType -->
    <xs:complexType name="segmentType">
        <xs:sequence>
            <xs:element name="biologicalAnnotation" minOccurs="0">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="description" minOccurs="0"/>
                        <xs:element name="externalReferences" minOccurs="0" maxOccurs="unbounded">
                            <xs:complexType>
                                <xs:simpleContent>
                                    <xs:extension base="xs:token">
                                        <xs:attribute name="type" use="required">
                                            <xs:simpleType>
                                                <xs:restriction base="xs:token">
                                                  <xs:enumeration value="uniprotkb"/>
                                                  <xs:enumeration value="uniparc"/>
                                                  <xs:whiteSpace value="collapse"/>
                                                  <xs:enumeration value="interpro"/>
                                                  <xs:enumeration value="go"/>
                                                  <xs:enumeration value="other"/>
                                                </xs:restriction>
                                            </xs:simpleType>
                                        </xs:attribute>
                                        <xs:attribute name="otherType" type="xs:token"/>
                                    </xs:extension>
                                </xs:simpleContent>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="numberOfInstances" type="xs:positiveInteger" minOccurs="0">
                            <xs:annotation>
                                <xs:documentation>Number of instances present of the basic structure
                                    (complex or macromolecule). For example it could be '7' for the
                                    upper ring of GroEL</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="complexesAndMacromolecules" type="macromoleculesAndComplexesType"
                minOccurs="0">
                <xs:annotation>
                    <xs:documentation>EMDB internal use</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="colour" type="colourType" minOccurs="0"/>
            <xs:sequence>
                <xs:element name="threeDVolume" type="threeDVolumeType" minOccurs="0"/>
                <xs:element name="shapePrimitiveList" minOccurs="0">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element ref="shapePrimitive" minOccurs="1" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="contourList" minOccurs="0">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="contour" type="contourType" minOccurs="1"
                                maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="meshList" minOccurs="0">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="mesh" type="surfaceType" minOccurs="1"
                                maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:sequence>
        <xs:attribute name="id" type="xs:positiveInteger" use="required"/>
        <xs:attribute name="parentID" type="xs:nonNegativeInteger" use="required">
            <xs:annotation>
                <xs:documentation>For the root segment: parentSegmentID = 0</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <!-- macromoleculesAndComplexesType -->
    <xs:complexType name="macromoleculesAndComplexesType">
        <xs:annotation>
            <xs:documentation>Depending on the problem, one can either reference the sample on the
                macromolecule level or the complex level. </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="macromolecule" minOccurs="0">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="id" type="xs:positiveInteger" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="complex" minOccurs="0">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="id" type="xs:positiveInteger" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <!-- threeDVolumeType -->
    <xs:complexType name="threeDVolumeType">
        <xs:sequence>
            <xs:element name="file" type="xs:token"/>
            <xs:element name="objectPath" type="xs:token" minOccurs="0">
                <xs:annotation>
                    <xs:documentation> This is particularly relevant if all the segments are stored
                        in one file, like in HDF5. </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="contourLevel" type="xs:float" minOccurs="0">
                <xs:annotation>
                    <xs:documentation> Should be specified if map is non-binary </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="transformId" type="xs:nonNegativeInteger" minOccurs="0"/>
            <xs:element name="format">
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="runLengthEncoding"/>
                        <xs:enumeration value="MRC"/>
                        <xs:enumeration value="Segger"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- surfaceType -->
    <xs:complexType name="surfaceType">
        <xs:sequence>
            <xs:element name="vertexList" type="vertexListType"/>
            <xs:element name="polygonList" type="polygonListType"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- vertexListType -->
    <xs:complexType name="vertexListType">
        <xs:sequence>
            <xs:element name="vertex" type="vertexType" minOccurs="3" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="numVertices" type="xs:positiveInteger"/>
    </xs:complexType>

    <!-- polygonListType -->
    <xs:complexType name="polygonListType">
        <xs:sequence maxOccurs="unbounded" minOccurs="1">
            <xs:element name="polygon" type="polygonType"/>
        </xs:sequence>
        <xs:attribute name="numPolygons" type="xs:positiveInteger"/>
    </xs:complexType>

    <!-- vertexType -->
    <xs:complexType name="vertexType">
        <xs:sequence>
            <xs:element name="x" type="xs:float"/>
            <xs:element name="y" type="xs:float"/>
            <xs:element name="z" type="xs:float"/>
        </xs:sequence>
        <xs:attribute name="vertexID" type="xs:positiveInteger"/>
    </xs:complexType>

    <!-- polygonType -->
    <xs:complexType name="polygonType">
        <xs:sequence>
            <xs:element name="vertex" type="xs:positiveInteger" minOccurs="3" maxOccurs="unbounded"
            />
        </xs:sequence>
        <xs:attribute name="polygonID" type="xs:positiveInteger"/>
    </xs:complexType>

    <!-- colorType -->
    <xs:complexType name="colourType">
        <xs:annotation>
            <xs:documentation> The 'name' corresponds to the sRGB colour space name and maps
                precisely to an RGB value. When this happens, the alpha channel should be set to '1'
                (opaque). Requires the use of an external Python module (webcolors.py).
            </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="name" type="xs:token"/>
            <xs:element name="rgba" type="rgbaType" minOccurs="1"/>
        </xs:choice>
    </xs:complexType>

    <!-- rgbaType -->
    <xs:complexType name="rgbaType">
        <xs:sequence>
            <xs:element name="red" type="colourChannelType"/>
            <xs:element name="green" type="colourChannelType"/>
            <xs:element name="blue" type="colourChannelType"/>
            <xs:element name="alpha" type="colourChannelType" default="1.0" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <!-- colourChannelType -->
    <xs:simpleType name="colourChannelType">
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0.0"/>
            <xs:maxInclusive value="1.0"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- contourType -->
    <xs:complexType name="contourType">
        <xs:sequence>
            <xs:element name="point" type="floatVectorType" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:nonNegativeInteger"/>
    </xs:complexType>

    <!-- floatVectorType -->
    <xs:complexType name="floatVectorType">
        <xs:attribute name="x" type="xs:float"/>
        <xs:attribute name="y" type="xs:float"/>
        <xs:attribute name="z" type="xs:float"/>
    </xs:complexType>

    <!-- dimensionType -->
    <xs:simpleType name="dimensionType">
        <xs:restriction base="xs:float">
            <xs:minExclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- END REFERENCED TYPES -->

    <!-- BEGIN REFERENCED ELEMENTS (in order of reference) -->
    <!-- transform -->
    <xs:element name="transform"/>
    <xs:element name="transformationMatrix" type="transformationMatrixType"
        substitutionGroup="transform"/>
    <xs:element name="canonicalEulerAngles" type="canonicalEulerAnglesType"
        substitutionGroup="transform"/>
    <xs:element name="viewVectorRotation" type="viewVectorRotationType"
        substitutionGroup="transform"/>

    <!-- shapePrimitive -->
    <xs:element name="shapePrimitive"/>
    <xs:element name="cuboid" substitutionGroup="shapePrimitive">
        <xs:annotation>
            <xs:documentation>3D rectangle</xs:documentation>
            <xs:documentation>'attribute' could refer to figure of merit (FOM)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="dimensions">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="x" type="dimensionType"/>
                            <xs:element name="y" type="dimensionType"/>
                            <xs:element name="z" type="dimensionType"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="transformId" type="xs:nonNegativeInteger"/>
                <xs:element name="attribute" type="xs:float"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:nonNegativeInteger"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="ellipsoid" substitutionGroup="shapePrimitive">
        <xs:annotation>
            <xs:documentation>3D sphere</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="axes">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="x" type="dimensionType"/>
                            <xs:element name="y" type="dimensionType"/>
                            <xs:element name="z" type="dimensionType"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="transformId" type="xs:nonNegativeInteger"/>
                <xs:element name="attribute" type="xs:float"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:nonNegativeInteger"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="cylinder" substitutionGroup="shapePrimitive">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="dimensions">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="height" type="dimensionType"/>
                            <xs:element name="diameter" type="dimensionType"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="transformId" type="xs:nonNegativeInteger"/>
                <xs:element name="attribute" type="xs:float"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:nonNegativeInteger"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="cone" substitutionGroup="shapePrimitive">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="dimensions">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="height" type="dimensionType"/>
                            <xs:element name="bottomRadius" type="dimensionType"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="transformId" type="xs:nonNegativeInteger"/>
                <xs:element name="attribute" type="xs:float"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:nonNegativeInteger"/>
        </xs:complexType>
    </xs:element>
    <!-- subTomogramAverage -->
    <xs:element name="subtomogramAverage" type="threeDVolumeType" substitutionGroup="shapePrimitive">
        <!--<xs:annotation>
            <xs:documentation>Deprecated</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="file" type="xs:token"/>
                <xs:element name="objectPath" type="xs:token"/>
                <xs:element name="transformId" type="xs:nonNegativeInteger"/>
                <xs:element name="attribute" type="xs:float"/>
            </xs:sequence>
        </xs:complexType>-->
    </xs:element>


    <!-- END REFERENCED ELEMENTS -->

    <!-- BEGIN DEPRECATED ELEMENTS -->


    <!-- END DEPRECATED ELEMENTS -->

    <!-- BEGIN DEPRECATED TYPES -->

    <!-- meshPointType (deprecated) -->
    <xs:complexType name="meshPointType">
        <xs:annotation>
            <xs:documentation>A mesh is a sequence of triangles</xs:documentation>
            <xs:documentation>Deprecated</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="point" type="floatVectorType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="index" type="xs:nonNegativeInteger"/>
        <xs:attribute name="designation">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="vertex"/>
                    <xs:enumeration value="normal"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <!-- hsvType (deprecated) -->
    <xs:complexType name="hsvType">
        <xs:annotation>
            <xs:documentation>Deprecated</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="hue" type="xs:float"/>
            <xs:element name="saturation" type="xs:float"/>
            <xs:element name="value" type="xs:float"/>
        </xs:sequence>
    </xs:complexType>

    <!-- runLengthEncodingType (deprecated) -->
    <xs:complexType name="runLengthEncodingType">
        <xs:annotation>
            <xs:documentation>Deprecated</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="string">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:pattern value="\d+(,\d+)+"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="offset" type="integerVectorType">
                <xs:annotation>
                    <xs:documentation>Offset of the segment relative to the orign
                        map.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="boxSize" type="positiveIntegerVectorType"/>
        </xs:sequence>
    </xs:complexType>

    <!-- integerVectorType (deprecated) -->
    <xs:complexType name="integerVectorType">
        <xs:annotation>
            <xs:documentation>Deprecated</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="x" type="xs:integer"/>
            <xs:element name="y" type="xs:integer"/>
            <xs:element name="z" type="xs:integer"/>
        </xs:sequence>
    </xs:complexType>

    <!-- positiveIntegerVectorType (deprecated) -->
    <xs:complexType name="positiveIntegerVectorType">
        <xs:sequence>
            <xs:element name="x" type="xs:positiveInteger"/>
            <xs:element name="y" type="xs:positiveInteger"/>
            <xs:element name="y" type="xs:positiveInteger"/>
        </xs:sequence>
    </xs:complexType>

    <!-- END DEPRECATED TYPES -->
</xs:schema>
